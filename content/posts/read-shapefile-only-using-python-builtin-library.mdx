---
title: Read shapefile using python-- the hard way
description: Read shapefile only using python's built in libraray
date: 2023-12-1
---

Shapefile is open source, well, sort of. ESRI did not provide any tool to read it easily, 
but at least it provided the technical 
[specification](https://www.esri.com/content/dam/esrisites/sitecore-archive/Files/Pdfs/library/whitepapers/pdfs/shapefile.pdf). 
So it won't be so hard to write our own library that reads binary from it and convert it to some format 
that is more friendly.  
In the blog, I will try to use python's built in library to read shapefile, and convert it to Geojson. 
So we can use it in our web application.
A Shapefile usually contains three files, .shp, .shx, .dbf. The .shp file contains the geometry information,
the .shx file contains the index information, and the .dbf file contains the attribute information.
There maybe be other files,like proj file about map project that is not compulsory and usually exclusively used by ESRI, so we will not try to Read and Convert it.  

Reading through the specification, we can find the shp file is quite intuitive, it only contains one geometry type,
if the geometry type is point, then the record is about a point, if the geometry type is polyline, 
then the record is multiple points that form a the geometry.  

<Image src="/shapefile1.png" width="718" height="404" alt="Image" />
The File Header takes up 100 bytes(50 words)
A lot of bytes is reserved and what we need is the file length and the geometry type which 
set at byte 24-27 and byte 32-35 respectively.
one thing we need to notice is that the byte order of file length is big endian, while the byte order of geometry type is little endian. 
after we know the these two crucial information, we can start to read the records.  
Each record Header takes up 8 bytes(4 words), I keep stress **word** cause it's used in the whitepaper extensively, and the Record Content length is variable and specified in the Record Header.  
<Image src='/recordHeader.png' width="718" height="404" alt="Image"/>
Every record Header contains the record number(integer) and the record length(integer), both are big endian that set at byte 0-3 and byte 4-7 respectively.
The record number begins with **1** and increments sequentially. The record length is the length of the record content in 16-bit words.
So each record takes up (2 byte * record length + 8) bytes

shapefile have a lot of types of geometry, but we will only focus on the three most common types, point, polyline and polygon.
A point consists of a pair of double-precision coordinates in the order X,Y.
The record content of point is quite simple, it only contains the x and y coordinate of the point, 
both are double precision floating point number, and both are little endian,

<Image src='/pointStructure.png' width='718' height="404" alt="Image"/>
----
<Image src="/PointStructure2.png" width='718' height="404" alt="Image"/>


while polyline and polygon contains a list of points;
<Image src="/polyline.png" width='718' height="404" alt="Image"/>
It also have a bounding box that is used to speed up the rendering process.
A polyline can be divide into multiple parts, each part is a list of points,
We can find the parts info at byte 44~(x-1), x = 44 + 4 * num_parts, the parts section stores the index of the first point of each part respect to
the following points section which is a array of points.  
For example, if the parts section is [0, 3, 5], then the first part is the first three points in the points section.

And what about polygon?
Actually, we can think of polygon as a special case of polyline, 
the only difference is that the last point of the polygon is the same as the first point.  
with thses information, we can start to write our own library to read shapefile's geometry information

First thing first, We need a class to represent the shapefile.
```python
class Shp(object):
    def __init__(self,*agrs):
        #set the path of the first parameter as the path of the shapefile when  Shp is initialized
        self.path=agrs[0] 
        self.shp=None
        #a list to hold file opened, so we can close them later
        self._file_to_close()=[]
        self.shpLength=None
        self.shapeType=None
        self.numShapes=None
        self.shapeName=None
        self.encoding = 'utf-8'
        self.encoding_errors = 'strict'
```
The very first information we need in order to read .shp file is the shp file's header,
So we load the shp file and read the header in the constructor.
```python
class Shp(object):
    def __init__(self,*args)
        ...
        self.load()

    def  load(self,shapeName):
        (shapeName, ext) = os.path.splitext(shapefile)
        self.shapeName = shapeName
        self.load_shp(shapeName)

    def load_shp(self,shapeName):
        self.shp = open("%s.%s" % (shapefile_name, "shp"), "rb")
        self.shx = open("%s.%s" % (shapefile_name, "shx"), "rb")
        self._file_to_close.append(self.shp)
        self._file_to_close.append(self.shx)
        if (self.shp):
            self.load_shp_header()
        if (self.shx):
            self.load_shx_header()
    def load_shp_header(self):
        shp = self.shp
        shp.seek(24)
        # file length big endian
        self.shpLength = unpack(">i", shp.read(4))[0] * 2
        # from word(2 bytes) to byte

        # shape type :little endian
        shp.seek(32)
        #small endian, one integer, 4 bytes
        self.shapeType = unpack("<i", shp.read(4))[0] #unpack returns a tuple,
        #so we need to get the first element of the tuple
        #four double that represent the bounding box
        self.bbox = _Array("d", unpack("<4d", shp.read(32)))
        #two double that represent the z box 
        self.zbox = _Array("d", unpack("<2d", shp.read(16)))
        #two double that represent the m box
        self.mbox = []
        for m in _Array("d", unpack("<2d", shp.read(16))):
            NODATA = -10e38 #according to the whitepaper, number < -10e38 is considered as nodata
            #we can also specify the nodata value at  the top of the file
            if m > NODATA:
                self.mbox.append(m)
            else:
                self.mbox.append(None)
    def load_shx_header(self):
        """Reads the header information from a .shx file."""
        shx = self.shx
        if not shx:
            raise Exception(
                "Shapefile Reader requires a shapefile or file-like object. (no shx file found"
            )
        # File length (16-bit word * 2 = bytes) - header length
        shx.seek(24)
        shxRecordLength = (unpack(">i", shx.read(4))[0] * 2) - 100
        self.numShapes = shxRecordLength // 8
    

```
So the shp's header has been read to momery
We can start to read the content of each feature's geometry
We can return a generator that yields the geometry of each feature,
the generator can be really helpful when we have a large shapefile
```python
# we create a Shape class to represent the geometry and header of each feature
class Shape(object):
    def __init__(
        self,   oid=None
    ):
        #parts are some information used by multiparts geometry
        #like multipolyline and multipolygon
        #we read it but do not use it
        self.shapeType = None
        self.points = []
        self.parts = []
        if partTypes:
            self.partTypes = partTypes

        # and a dict to silently record any errors encountered
        self._errors = {}

        # add oid which is the index of the feature in the shapefile
        if oid is not None:
            self.__oid = oid
        else:
            self.__oid = -1





class Shp(object):
    ... 

    def iterShapes(self, bbox=None):
        """Returns a generator of shapes in a shapefile. Useful
        for handling large shapefiles.
        To only read shapes within a given spatial region, specify the 'bbox'
        arg as a list or tuple of xmin,ymin,xmax,ymax.
        """
        shp = self.__getFileObj(self.shp)
        # Found shapefiles which report incorrect
        # shp file length in the header. Can't trust
        # that so we seek to the end of the file
        # and figure it out.
        shp.seek(0, 2)
        shpLength = shp.tell()
        shp.seek(100)


        # Instead iterate until reach end of file
        # Collect the offset indices during iteration
        i = 0
        offsets = []
        pos = shp.tell()
        while pos < shpLength:
            offsets.append(pos)
            shape = self.setShapeIndex(oid=i, )
            pos = shp.tell()
            if shape:
                yield shape
            i += 1
        # Entire shp file consumed
        # Update the number of shapes and list of offsets
        assert i == len(offsets)
        self.numShapes = i
        self._offsets = offsets
        










```
the Shape class can be converted to json use the to_json method
```python
class Shape(object):
    ...
    def to_json(self):
        if self.shapeType=="Point":
            # the point only contains one point
            return {"type": "Point", "coordinates": tuple(self.points[0])}
        elif self.shapeType=="Polyline":
            if len(self.parts) == 0:
                # the shape has no coordinate information, i.e. is 'empty'
                # the geojson spec does not define a proper null-geometry type
                # however, it does allow geometry types with 'empty' coordinates to be interpreted as null-geometries
                return {"type": "LineString", "coordinates": []}
            elif len(self.parts) == 1:
                # linestring
                return {
                    "type": "LineString",
                    "coordinates": [tuple(p) for p in self.points],
                }
            else:
                # multilinestring
                ps = None
                coordinates = []
                for part in self.parts:
                    if ps == None:
                        ps = part
                        continue
                    else:
                        coordinates.append([tuple(p) for p in self.points[ps:part]])
                        ps = part
                else:
                    coordinates.append([tuple(p) for p in self.points[part:]])
                return {"type": "MultiLineString", "coordinates": coordinates}
        elif self.shapeType=="Polygon":
            if len(self.parts) == 0:
                # the shape has no coordinate information, i.e. is 'empty'
                # the geojson spec does not define a proper null-geometry type
                # however, it does allow geometry types with 'empty' coordinates to be interpreted as null-geometries
                return {"type": "Polygon", "coordinates": []}
            else:
                # get all polygon rings
                rings = []
                for i in range(len(self.parts)):
                    # get indexes of start and end points of the ring
                    start = self.parts[i]
                    try:
                        end = self.parts[i + 1]
                    except IndexError:
                        end = len(self.points)

                    # extract the points that make up the ring
                    ring = [tuple(p) for p in self.points[start:end]]
                    rings.append(ring)

                # organize rings into list of polygons, where each polygon is defined as list of rings.
                # the first ring is the exterior and any remaining rings are holes (same as GeoJSON).
                polys = organize_polygon_rings(rings, self._errors)

                # return as geojson
                if len(polys) == 1:
                    return {"type": "Polygon", "coordinates": polys[0]}
                else:
                    return {"type": "MultiPolygon", "coordinates": polys}

        else:
            
            raise Exception("Unknown shape type")


```
